# PROMPT 3: Database Setup ve Prisma Schema

## 🎯 Amaç
Bu aşamada PostgreSQL veritabanı bağlantısını yapacağız, Prisma schema'yı tanımlayacağız ve in-memory storage'ı database ile değiştireceğiz.

## 📋 Önkoşullar
- ✅ Prompt 1 ve 2 tamamlanmış olmalı
- ✅ PostgreSQL kurulu olmalı VEYA Render/Supabase ücretsiz database kullanılabilir

---

## 🗄️ Database Seçenekleri

### Seçenek 1: Local PostgreSQL
```bash
# PostgreSQL kurulu olmalı
# Database oluştur
createdb aidoctor

# DATABASE_URL:
postgresql://localhost:5432/aidoctor
```

### Seçenek 2: Render (ÖNERİLEN - Ücretsiz)
1. https://dashboard.render.com/ adresine git
2. "New" -> "PostgreSQL" seç
3. Ücretsiz plan seç
4. Database oluştur
5. "External Database URL" kopyala
6. .env dosyasına ekle

### Seçenek 3: Supabase (Ücretsiz)
1. https://supabase.com/ adresine git
2. Yeni proje oluştur
3. Settings -> Database -> Connection string kopyala
4. .env dosyasına ekle

---

## 📋 Yapılacaklar

### 1. Prisma Schema Tanımla

**prisma/schema.prisma**
```prisma
// Prisma Schema for AI-Doctor

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Model (Doctor)
model User {
  id                  String   @id @default(uuid())
  email               String   @unique
  password            String
  name                String
  title               String?
  specialty           String?
  phone               String?
  subscriptionType    SubscriptionType @default(FREE)
  subscriptionEndDate DateTime?
  isVerified          Boolean  @default(false)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  patients            Patient[]
  notifications       Notification[]

  @@index([email])
}

// Patient Model
model Patient {
  id             String          @id @default(uuid())
  userId         String
  name           String
  age            Int
  gender         Gender
  identityNumber String?
  phone          String?
  admissionTime  DateTime        @default(now())
  complaint      String
  status         PatientStatus   @default(EVALUATION)
  priority       PatientPriority @default(MEDIUM)
  isActive       Boolean         @default(true)
  dischargeTime  DateTime?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  // Relations
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  vitalSigns     VitalSign[]
  medicalHistory MedicalHistory?
  labResults     LabResult[]
  imagingResults ImagingResult[]
  aiAnalyses     AIAnalysis[]
  notes          PatientNote[]
  chatMessages   ChatMessage[]

  @@index([userId])
  @@index([status])
  @@index([isActive])
}

// Vital Signs Model
model VitalSign {
  id                      String   @id @default(uuid())
  patientId               String
  bloodPressureSystolic   Int?
  bloodPressureDiastolic  Int?
  heartRate               Int?
  temperature             Float?
  oxygenSaturation        Int?
  respiratoryRate         Int?
  consciousness           String?
  recordedAt              DateTime @default(now())
  createdAt               DateTime @default(now())

  // Relations
  patient                 Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@index([patientId])
}

// Medical History Model
model MedicalHistory {
  id                String   @id @default(uuid())
  patientId         String   @unique
  complaintHistory  String?
  medicalHistory    String?
  surgicalHistory   String?
  familyHistory     String?
  allergies         String?
  currentMedications Json?
  smoking           Boolean  @default(false)
  alcohol           Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  patient           Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)
}

// Lab Results Model
model LabResult {
  id         String        @id @default(uuid())
  patientId  String
  testName   String
  testType   LabTestType
  results    Json
  status     TestStatus    @default(PENDING)
  orderedAt  DateTime      @default(now())
  resultedAt DateTime?
  notes      String?
  createdAt  DateTime      @default(now())

  // Relations
  patient    Patient       @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@index([patientId])
  @@index([status])
}

// Imaging Results Model
model ImagingResult {
  id           String       @id @default(uuid())
  patientId    String
  imagingType  ImagingType
  bodyPart     String
  findings     String?
  imageUrl     String?
  status       TestStatus   @default(PENDING)
  orderedAt    DateTime     @default(now())
  completedAt  DateTime?
  createdAt    DateTime     @default(now())

  // Relations
  patient      Patient      @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@index([patientId])
}

// AI Analysis Model
model AIAnalysis {
  id           String       @id @default(uuid())
  patientId    String
  analysisType AnalysisType
  inputData    Json
  outputData   Json
  confidence   Float?
  references   Json?
  createdAt    DateTime     @default(now())

  // Relations
  patient      Patient      @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@index([patientId])
}

// Patient Notes Model
model PatientNote {
  id        String   @id @default(uuid())
  patientId String
  userId    String
  noteType  NoteType
  content   String
  createdAt DateTime @default(now())

  // Relations
  patient   Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@index([patientId])
}

// Chat Messages Model
model ChatMessage {
  id        String      @id @default(uuid())
  patientId String
  userId    String
  role      ChatRole
  content   String
  metadata  Json?
  createdAt DateTime    @default(now())

  // Relations
  patient   Patient     @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@index([patientId])
}

// Notifications Model
model Notification {
  id           String           @id @default(uuid())
  userId       String
  patientId    String?
  type         NotificationType
  title        String
  message      String
  isRead       Boolean          @default(false)
  scheduledFor DateTime?
  createdAt    DateTime         @default(now())

  // Relations
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
}

// Enums
enum SubscriptionType {
  FREE
  PREMIUM
  ENTERPRISE
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum PatientStatus {
  EVALUATION
  LAB_WAITING
  CONSULTATION
  READY
  DISCHARGED
}

enum PatientPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum LabTestType {
  BLOOD
  URINE
  OTHER
}

enum ImagingType {
  XRAY
  CT
  MRI
  ULTRASOUND
  OTHER
}

enum TestStatus {
  PENDING
  COMPLETED
  REVIEWED
}

enum AnalysisType {
  DIAGNOSIS
  TREATMENT
  TEST_RECOMMENDATION
}

enum NoteType {
  OBSERVATION
  PROGRESS
  CONSULTATION_REQUEST
  CONSULTATION_RESPONSE
}

enum ChatRole {
  USER
  ASSISTANT
}

enum NotificationType {
  LAB_RESULT
  REMINDER
  CRITICAL_VALUE
  SYSTEM
}
```

---

### 2. .env Dosyasını Güncelle

**.env** (kendi database URL'inizi kullanın)
```
NODE_ENV=development
PORT=5000

# Render PostgreSQL örneği:
DATABASE_URL=postgresql://aidoctor_user:password@dpg-xxxxx.oregon-postgres.render.com/aidoctor

# Veya Local:
# DATABASE_URL=postgresql://localhost:5432/aidoctor

JWT_SECRET=your-super-secret-jwt-key-change-this
JWT_REFRESH_SECRET=your-refresh-secret-key-change-this
JWT_EXPIRE=15m
JWT_REFRESH_EXPIRE=7d
```

---

### 3. Prisma Generate ve Migrate

```bash
cd backend

# Prisma client generate et
npx prisma generate

# İlk migration oluştur
npx prisma migrate dev --name init

# Prisma Studio'yu aç (database GUI)
npx prisma studio
```

---

### 4. Auth Controller'ı Database Kullanacak Şekilde Güncelle

**src/controllers/authController.js** güncelle:

```javascript
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { PrismaClient } = require('@prisma/client');
const { successResponse, errorResponse } = require('../utils/response');
const logger = require('../utils/logger');

const prisma = new PrismaClient();

// Generate JWT Token
const generateToken = (userId) => {
  return jwt.sign({ userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRE || '15m'
  });
};

// Generate Refresh Token
const generateRefreshToken = (userId) => {
  return jwt.sign({ userId }, process.env.JWT_REFRESH_SECRET, {
    expiresIn: process.env.JWT_REFRESH_EXPIRE || '7d'
  });
};

// @desc    Register new user
// @route   POST /api/auth/register
// @access  Public
const register = async (req, res) => {
  try {
    const { email, password, name, title, specialty, phone } = req.body;

    // Validation
    if (!email || !password || !name) {
      return errorResponse(res, 400, 'Email, password and name are required');
    }

    // Email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return errorResponse(res, 400, 'Invalid email format');
    }

    // Password strength check
    if (password.length < 6) {
      return errorResponse(res, 400, 'Password must be at least 6 characters');
    }

    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { email }
    });

    if (existingUser) {
      return errorResponse(res, 400, 'User already exists with this email');
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user in database
    const newUser = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name,
        title: title || '',
        specialty: specialty || '',
        phone: phone || '',
        subscriptionType: 'FREE'
      }
    });

    logger.info('New user registered', { email, userId: newUser.id });

    // Generate tokens
    const accessToken = generateToken(newUser.id);
    const refreshToken = generateRefreshToken(newUser.id);

    // Don't send password in response
    const { password: _, ...userWithoutPassword } = newUser;

    return successResponse(res, 201, 'User registered successfully', {
      user: userWithoutPassword,
      accessToken,
      refreshToken
    });

  } catch (error) {
    logger.error('Registration error', { error: error.message });
    return errorResponse(res, 500, 'Registration failed', error.message);
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Validation
    if (!email || !password) {
      return errorResponse(res, 400, 'Email and password are required');
    }

    // Find user in database
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return errorResponse(res, 401, 'Invalid email or password');
    }

    // Check password
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return errorResponse(res, 401, 'Invalid email or password');
    }

    logger.info('User logged in', { email, userId: user.id });

    // Generate tokens
    const accessToken = generateToken(user.id);
    const refreshToken = generateRefreshToken(user.id);

    // Don't send password in response
    const { password: _, ...userWithoutPassword } = user;

    return successResponse(res, 200, 'Login successful', {
      user: userWithoutPassword,
      accessToken,
      refreshToken
    });

  } catch (error) {
    logger.error('Login error', { error: error.message });
    return errorResponse(res, 500, 'Login failed', error.message);
  }
};

// @desc    Refresh access token
// @route   POST /api/auth/refresh
// @access  Public
const refreshToken = async (req, res) => {
  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      return errorResponse(res, 400, 'Refresh token is required');
    }

    // Verify refresh token
    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);

    // Find user in database
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId }
    });

    if (!user) {
      return errorResponse(res, 401, 'User not found');
    }

    // Generate new access token
    const newAccessToken = generateToken(user.id);

    return successResponse(res, 200, 'Token refreshed successfully', {
      accessToken: newAccessToken
    });

  } catch (error) {
    logger.error('Refresh token error', { error: error.message });
    
    if (error.name === 'JsonWebTokenError') {
      return errorResponse(res, 401, 'Invalid refresh token');
    }
    if (error.name === 'TokenExpiredError') {
      return errorResponse(res, 401, 'Refresh token expired');
    }
    
    return errorResponse(res, 500, 'Token refresh failed', error.message);
  }
};

// @desc    Get current user profile
// @route   GET /api/auth/me
// @access  Private
const getMe = async (req, res) => {
  try {
    // Find user in database
    const user = await prisma.user.findUnique({
      where: { id: req.user.userId },
      select: {
        id: true,
        email: true,
        name: true,
        title: true,
        specialty: true,
        phone: true,
        subscriptionType: true,
        subscriptionEndDate: true,
        isVerified: true,
        createdAt: true,
        updatedAt: true
      }
    });
    
    if (!user) {
      return errorResponse(res, 404, 'User not found');
    }

    return successResponse(res, 200, 'User profile retrieved', user);

  } catch (error) {
    logger.error('Get profile error', { error: error.message });
    return errorResponse(res, 500, 'Failed to get profile', error.message);
  }
};

module.exports = {
  register,
  login,
  refreshToken,
  getMe
};
```

---

## ✅ Test Adımları

### 1. Prisma Migrate Başarılı mı Kontrol Et
```bash
npx prisma migrate status
```

Beklenen çıktı:
```
Database schema is up to date!
```

### 2. Prisma Studio'yu Aç
```bash
npx prisma studio
```
Browser'da http://localhost:5555 açılacak ve tüm tabloları görebileceksiniz.

### 3. Server'ı Başlat ve Test Et
```bash
npm run dev
```

### 4. Register Test Et (Database'e Kayıt)
```bash
curl -X POST http://localhost:5000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "doctor@aidoctor.com",
    "password": "123456",
    "name": "Dr. Ahmet Yılmaz",
    "title": "Acil Tıp Uzmanı",
    "specialty": "Acil Tıp",
    "phone": "+905551234567"
  }'
```

### 5. Prisma Studio'da Kontrol Et
- Prisma Studio'da User tablosuna bak
- Yeni kullanıcı görünmeli
- Password hash'lenmiş olmalı

### 6. Login Test Et
```bash
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "doctor@aidoctor.com",
    "password": "123456"
  }'
```

### 7. Get Profile Test Et
```bash
curl -X GET http://localhost:5000/api/auth/me \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

---

## 📝 Tamamlanma Kriterleri

✅ Prisma schema tanımlandı (tüm modeller)  
✅ Database bağlantısı yapıldı  
✅ Migration başarılı  
✅ Prisma Studio çalışıyor  
✅ User register database'e yazıyor  
✅ User login database'den okuyor  
✅ Password hash'lenerek saklanıyor  
✅ Token'lar çalışıyor  
✅ Prisma client import ediliyor  

---

## 🚀 Sonraki Adım

Bu aşama tamamlandığında **PROMPT 4: Patient CRUD API** ile devam edeceğiz.

Prompt 4'te:
- Hasta ekleme, listeleme, güncelleme, silme endpoints'lerini yapacağız
- Subscription kontrolü (free tier 3 hasta limiti)
- User authorization (başkasının hastasına erişememe)

---

## ⚠️ Önemli Notlar

1. **DATABASE_URL'i .env'e doğru yazdığınızdan emin olun**
2. **Migration sırasında hata alırsanız: `npx prisma migrate reset`**
3. **Prisma Studio ile database'i görsel kontrol edebilirsiniz**
4. **Production'da Prisma client'ı optimize edin (connection pooling)**
5. **Schema değişikliklerinde yeni migration oluşturun**

---

## 🐛 Troubleshooting

**Hata: "Can't reach database server"**
→ DATABASE_URL'i kontrol edin, database çalışıyor mu?

**Hata: "Prisma Client validation failed"**
→ `npx prisma generate` komutu ile client'ı yeniden oluşturun

**Hata: "Migration failed"**
→ Database'i sıfırlayın: `npx prisma migrate reset`

---

**Bu prompt tamamlandığında "Prompt 3 tamamlandı, database bağlantısı çalışıyor, user kayıt oluyor" diye cevap verin ve Prompt 4'e geçin.**
